<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="19">
  <Forms>
    <EditView Class="TCEForm" Encoding="Ascii85">tyo*V990.e;?,*j%f%X7#iEl3wJj!1)yK[3=B;$e#ID(T(C+)!ojpy4OlG#Tv#Ci7YHL9#S];W/Qd%rpRN^-EeUwJ/rC1dO5yU)STBu-OL;m7y@Uq}x(n6RU!pF_#JKz7Ef6n;m-,k,0j;}6/dW3vta7Z[1VuK}c99PJx4I_]*$-fba9w5r)l+#XD.]4f$f4]}uh+C1A[.XFkv}HA$aZuK@N-_Yca(r{v%#0GPnkXuxil*pc@MpfI(YV,.kSbR4x}=8kw32;G$Vg;V)Y5HVtfWmABr((7oFzuLcql7U2jY[:H6y0y#D3XODvB:Vs%4PMi34Odl}EO/nXbE{eeRfxQ)N5wk_]w(f#Wm*$2GzKrVjckauaZ66I_QMd7tz.^acQ5T#2+c^H=64G):{-:XSsez.VDl.y7O0zS]IZdI]V]U/@:3o!0=VfQx]+fMMh$*{blm+mI}$eV*WP+8x=*X@dA2qYWJM%9Shh@C+rz1W+B!h$-_,W4%gqN#m?c]68ghcTUF-GI(GiJ%Q(Pfbk%2]9fDG.51,na1-z:.5R){6z}!t0eGCjTgGF0O]/(1ybM=gfnNX?L-3X^KE:.==GM05fHGhTa6K@Q29CQ8[yl/.7])61a{2O@]9e33:UV@:01E.BJ-^}LMUnR=@4/(j[T}5).0yHJXpV0q?AEZymr-,Jjhx-YIlsFG=[0^V[V$IYhZy%4Q71$1W9$wF=:$2LI6U9^;H4]F.4k3wn8#.w51-l9HF+CbFX7AW-4JVt]uipXZ[)$w/A/_P*Aji!:JPMWEj,#i7^j?Bpg*Iq2k.#p*4h.*^QCB1p0SSy8tmg=-#OjK^cF=,gVr59rZsIp*+64@83d#$2kVZxjykywumI2jXD_l6[aUGFxQgecb:F^}t^)(ttc!DiHvzqP9:fit?+X-+a{?SH@nd;ehqa8VSBMa(ZH09h%jy,^zVU[DvYwL-LbMFLvWdaPp!+n,ibRd!XRp/MM3UHjMA}Tc5oxu1kH{]Xb:Z)AD[Sxu8K9HVRo#d_WDui]Lo:Z[ZJ]NAXtO1hM4?cru:YHe%NnFo5n3$1a}jJ[#ly67iEyzTQFEqbm:P]xha+Irgt0KkI?@6r,kF]Aao2WprfSSe4SYw5b)d+.2g]V=J*qusQ,Ve*S/d/M9L9UfwJt23*h4T_-oU(-2FN5lS+H6{Snk[!M7^k.c;BAUi9e3/9]h1E4xaUf3x,nPOy?[}3x?LRee;ac=]Ecbk(+VCs,Wm4)J/{S^Rx)N^u..5yFH{d_Az4X[b}nc*X.xnb@isX_68m1FVy;Q4*1?j^WWKat6ex{FkssCpTcD=jw)iQ/GQMGbwH[?k_x^BpKot,WJOE11!c#*wDj%j;F)+7OAP6n+:-35(9XX1N:fSq4+$I-V!{S5gcxH@]]B}ZjKO:^.0fw;:;ttx8qUbke1?$#fttHr(3INnMGP?58I2?*HJfIqXB5=jT)xL#4@59hJA$mHRY^%;ou4EG(P*,]I/3E*l8bc9j[Iak.xqcnozjEWV!Q4vwv):ljg-H1ZRx5mmUQ?v3Kb+/Z=]G/*:Gqpeo6b9w-TeZ.S,K)Evf2:qBRKqqZ9n78?vVBQ/7Mc#G/ZBUfgz1D.QPqWjmqT*wN%lVJE#?pY*x3f:O=aRr/aD0E_:V+!3@YxbtG}VXvgUXhZaD@s8pI?m;;D]#yVCT[]u/=X/2wI.$D}v^JB@U?1*,dQ}gk$DHhLg{,fdC.k$n4CaXeQhMWA4O=cIv+O:z1fTU9AlM.K1op:.=X2!(I?rZ+b%JlPg10*q^Oo9QqthQ@2)7^.vB;/D#[udDt9c?,HOBr7xpAX%)QD=OtJySeRqgOLN6MxLH%35Ikc,-fE1:q2uiAqAplrO)tJg.aR0}Y6lpYjK*QZOBqQ9{KmE}XK;UCS45kci-owC1o2q:HdR/:h3l}Zix0#o[;Rg=:s/)9fSZoOxQrRrpZQhLXcFT1O=-F]P(gT$e#s?7C-PcRs}RTzhLT}vvGw=tLTX]o;dYh!yIKM%zxuo,(EX6No;m$Ezdf1J=!-Ox$9@-3E:nhw.RIH.zprm1TW6iv.]08LIXt(dpxw.g?Gaaygfeu[LTY@oEru6vnnvnQ5UW^43Vl?!f7iXEh13TGuXQUWRKlF*2?[}:Q}d,iE=ngoxh6!S++xg+/s#Gpu/;AXWj2z3O:@@R!G8G.:+(k]#6s43GbB%!!1roGwLLoS3Q,XW(N,0J*Js]t=Asr:tfzGvexF]e9h</EditView>
  </Forms>
  <LuaScript>-- Script Edit e View PangYa S8 Ver. [JP/USA] By Acrisio SuperSS Dev
-- Criado em 10/11/2019 as 12:00 por Acrisio
-- Update 22/11/2019 13:54 [Add All Freeze values "Spin, Curva, Vento, Ângulo, Slope X e Slope Y"]
--
MapSearch = {
    state = nil,
    const_addr = 0x00E3CFD4, -- JP 0x00E73E60
    link = {[1] = 0x34, [2] = 0x30, [3] = 0x10, [4] = 0x2c, [5] = 0x18},
    MapEntry = 0,
    pin = {0, 0, 0},
    tee = {0, 0, 0},
    ball_ground = {0, 0},
    ball_effect = {0, 0},
    ball_line = 0,
    ground = 0, -- Terreno
    wind = {0, 0},
    wind_rotate = 0.00,
    mira = 0.00,
    distancia = 0.00,
    altura = 0.00,
    pb = 0.00,
    grid_mira_radiano = 0.00,
    power_gauge = 0.0,
    const_addr_power_gauge = 0xE10FAC, -- JP 0xE47E2C  -- Constante players info
    init = function(self)

        if process then

            self.MapEntry = readInteger(self.const_addr)

            if self.MapEntry and self.MapEntry &gt; 0 then

                for i,v in ipairs(self.link) do

                    if self.MapEntry and self.MapEntry &gt; 0 then
                        self.MapEntry = readInteger(self.MapEntry+v)
                    end
                end
            end

            if self.MapEntry and self.MapEntry &gt; 0 then
                self.state = true
            end
        else
            self.state = nil
        end
    end,
    findMap = function(self, name)

        -- Initialize, all time check new values pointers
        self:init()

        mapAllocedElement = 0

        if self.MapEntry and self.MapEntry &gt; 0 then

            while self.MapEntry ~= 0 and mapAllocedElement == 0 do

                if readString(readInteger(self.MapEntry+4), 16) == name then
                    mapAllocedElement = readInteger(self.MapEntry)
                else
                    self.MapEntry = readInteger(self.MapEntry+0x14)
                end
            end
        end

        return mapAllocedElement
    end,
    getScreenStruct = function(self)

        st_screen_ptr = self:findMap('Screen')

        if not st_screen_ptr then
            return nil
        else
            return readInteger(st_screen_ptr)
        end
    end,
    getGridStruct = function(self)

        st_grid_ptr = self:findMap('Grid')

        if not st_grid_ptr then
            return nil
        else
            return {
                this = readInteger(st_grid_ptr),
                grid_mira_radiano = 0,
                init = function(self)

                    -- Initialize data
                    if self.this then
                        self.grid_mira_radiano = self.this+0x3064 -- JP 0x6944
                    else
                        if log then
                            print('Não conseguiu achar o ponteiro do grid. ' .. string.format('%s', self.this))
                        end
                    end
                end
            }
        end
    end,
    getSpinStruct = function(self)

        st_spin_ptr = self:findMap('Spin')

        if not st_spin_ptr then
            return nil
        else
            return {
                this = readInteger(st_spin_ptr),
                curva = 0,
                spin = 0,
                curvaLimit = 0,
                spinLimit = 0,
                init = function(self, option)

                    if self.this then
                        -- Initialize Address
                        self.curva = self.this+0x18
                        self.spin = self.this+0x1C
                        self.curvaLimit = self.this+0x20
                        self.spinLimit = self.this+0x24
                    else
                        if log then
                            print('Não conseguiu achar o ponteiro do spin. ' .. string.format('%s', self.this))
                        end
                    end
                end
            }
        end
    end,
    getSlopGroundStruct = function(self)

        st_screen_ptr = self:getScreenStruct()

        if not st_screen_ptr then
            return nil
        else
            return {
                this = readInteger(st_screen_ptr+0x21C),
                ground_x = 0,
                ground_y = 0,
                ground = 0,
                line_rotate = 0,
                line_size = 0,
                init = function(self, option)

                    if self.this then
                      -- Initialize Address
                      self.ground_x = self.this+0x1C
                      self.ground_y = self.this+0x24
                      self.line_rotate = self.this+0xE8
                      self.line_size = self.this+0x20
                      self.ground = self.this+0xAC
                    else
                        if log then
                            print('Não conseguiu encontrar o ponteiro do Slop Ground. ' .. string.format('%x', self.this))
                        end
                    end
                end
            }
        end
    end,
    getClassicWindStruct = function(self)

        const_addr_wind_ptr = 0x00E403A4 -- JP 0x00E79064

        array_heap = {
            first_ptr = readInteger(const_addr_wind_ptr),
            table_ptr = 0,
            max_element = 0,
            index_1 = readInteger(const_addr_wind_ptr+0x0C),
            index_2 = readInteger(const_addr_wind_ptr+0x10),
            index = 0,
            address = 0,
            getIndex = function(self)
                if self.index_1 and self.index_2 then
                    return self.index_1 + self.index_2
                else
                    return nil
                end
            end,
            init = function(self)

                -- Verifica se o first ptr é valído
                if self.first_ptr and self.first_ptr &gt; 0 then

                    self.first_ptr = readInteger(self.first_ptr)

                    if self.first_ptr and self.first_ptr &gt; 0 then
                        self.first_ptr = readInteger(self.first_ptr)
                    end

                    -- Index real
                    self.index = self:getIndex() - 1

                    -- Calcular address
                    if self.first_ptr and self.first_ptr &gt; 0 then

                        self.max_element = readInteger('[' .. string.format('%x', self.first_ptr) .. ']+8')

                        if self.index &gt;= self.max_element then
                            self.index = self.index - self.max_element
                        end

                        self.table_ptr = readInteger('[' .. string.format('%x', self.first_ptr) .. ']+4')

                        if self.first_ptr and self.table_ptr &gt; 0 then

                            st = readInteger(self.table_ptr + (self.index * 4))

                            if st and st &gt; 0 then

                                self.address = readInteger(st)
                                self.address = self.address ~ readInteger(st+8)
                                self.address = ~self.address &amp; 0xFFFFFFFF
                            end
                        end

                    end
                end

            end
        }

        array_heap:init()

        if array_heap.address == 0 then
            return nil
        else
            return {
                this = array_heap.address,
                wind_speed = 0,
                wind_direction = 0,
                wind_rotate = 0,
                table_wind_value = nil,
                init = function(self, option)

                    -- Initialize Address
                    self.table_wind_value = {
                        addres_ptr = 0,
                        speed_1 = {0, 0},
                        speed_2 = {0, 0},
                        speed_3 = {0, 0},
                        wind_speed = 0,
                        wind_direction = 0,
                        init = function(self, wind_addr)

                            -- Address
                            table_wind_value_ptr = 0

                            if readBytes(wind_addr+0x170, 1) == 0 then
                                table_wind_value_ptr = wind_addr + 0xD8
                            else
                                table_wind_value_ptr = wind_addr + 0x114
                            end

                            if table_wind_value_ptr ~= 0 then

                                value1 = 0
                                value2 = 0
                                value3 = 0

                                -- Wind Speed
                                self.speed_1[1] = readInteger(table_wind_value_ptr)
                                self.speed_1[2] = readInteger(table_wind_value_ptr+8)

                                self.speed_2[1] = readInteger(table_wind_value_ptr+0x10)
                                self.speed_2[2] = readInteger(table_wind_value_ptr+0x18)

                                self.speed_3[1] = readInteger(table_wind_value_ptr+0x20)
                                self.speed_3[2] = readInteger(table_wind_value_ptr+0x28)

                                value1 = self.speed_1[1] ~ self.speed_1[2]
                                value2 = self.speed_2[1] ~ self.speed_2[2]
                                value3 = self.speed_3[1] ~ self.speed_3[2]

                                value1 = byteTableToFloat(dwordToByteTable(~value1 &amp; 0xFFFFFFFF))
                                value2 = byteTableToFloat(dwordToByteTable(~value2 &amp; 0xFFFFFFFF))
                                value3 = byteTableToFloat(dwordToByteTable(~value3 &amp; 0xFFFFFFFF))

                                value1 = value1 * value1
                                value2 = value2 * value2
                                value3 = value3 * value3

                                self.wind_speed = tonumber(string.format('%.1f', math.sqrt(value1 + value2 + value3)))

                                -- Wind direction
                                cos = self.speed_3[1] ~ self.speed_3[2]
                                sin = self.speed_1[1] ~ self.speed_1[2]

                                sin = byteTableToFloat(dwordToByteTable(~sin &amp; 0xFFFFFFFF))
                                cos = byteTableToFloat(dwordToByteTable(~cos &amp; 0xFFFFFFFF))

                                -- sin, cos
                                if self.wind_speed &gt; 0.0 then
                                    sin = sin / self.wind_speed * -1.0
                                    cos = cos / self.wind_speed
                                end

                                graus_sin = tonumber(string.format('%.2f', math.deg(math.asin(sin))))
                                graus_cos = tonumber(string.format('%.2f', math.deg(math.acos(cos))))

                                if graus_sin &lt; 0.0 then
                                    self.wind_direction = 180.0 - (graus_cos - 180.0)
                                else
                                    self.wind_direction = graus_cos
                                end
                            end
                        end,
                        makeWindAndAng = function(self, wind_addr)

                            table_wind_value_ptr = 0

                            if readBytes(wind_addr+0x170, 1) == 0 then
                                table_wind_value_ptr = wind_addr + 0xD8
                            else
                                table_wind_value_ptr = wind_addr + 0x114
                            end

                            if table_wind_value_ptr ~= 0 then

                                value1 = 0
                                value2 = 0
                                value3 = 0
                                mask1 = 0
                                mask2 = 0
                                mask3 = 0

                                mask1 = table_wind_value_ptr
                                mask2 = table_wind_value_ptr+0x10
                                mask3 = table_wind_value_ptr+0x20

                                ang = self.wind_direction

                                sin = math.sin(math.rad(ang)) * -1.0 -- invert
                                cos = math.cos(math.rad(ang))

                                value1 = self.wind_speed * sin
                                value3 = self.wind_speed * cos

                                value1 = byteTableToDword(floatToByteTable(value1))
                                value3 = byteTableToDword(floatToByteTable(value3))

                                self.speed_1[1] = (~value1 &amp; 0xFFFFFFFF) ~ self.speed_1[2]
                                self.speed_2[1] = (~value2 &amp; 0xFFFFFFFF) ~ self.speed_2[2]
                                self.speed_3[1] = (~value3 &amp; 0xFFFFFFFF) ~ self.speed_3[2]

                                mask1 = mask1 ~ self.speed_1[1]
                                mask2 = mask2 ~ self.speed_2[1]
                                mask3 = mask3 ~ self.speed_3[1]

                                -- test write
                                writeInteger(table_wind_value_ptr, self.speed_1[1])
                                writeInteger(table_wind_value_ptr+4, mask1)
                                writeInteger(table_wind_value_ptr+0x10, self.speed_2[1])
                                writeInteger(table_wind_value_ptr+0x14, mask2)
                                writeInteger(table_wind_value_ptr+0x20, self.speed_3[1])
                                writeInteger(table_wind_value_ptr+0x24, mask3)
                            end
                        end
                    }

                    self.table_wind_value:init(self.this)

                    self.wind_speed = self.table_wind_value.wind_speed
                    self.wind_direction = self.table_wind_value.wind_direction
                    self.wind_rotate = self.this+0x58
                end
            }
        end
    end,
    getTeeAndPinStruct = function(self)

        const_addr_tee = 0x00E1107C -- JP 0x00E47EFC
        const_addr_pin = 0x00EC445C -- JP 0x00EFD154

        if self.state and self.state == true then

            -- Tee X, Y, Z
            self.tee[1] = readFloat(const_addr_tee)
            self.tee[2] = readFloat(const_addr_tee+4)
            self.tee[3] = readFloat(const_addr_tee+8)

            -- Pin X, Y, Z
            self.pin[1] = readFloat(const_addr_pin)
            self.pin[2] = readFloat(const_addr_pin+4)
            self.pin[3] = readFloat(const_addr_pin+8)

            if self.tee[1] and self.tee[2] and self.tee[3] and self.pin[1] and self.pin[2] and self.pin[3] then

                -- Calula distância
                self.distancia = math.sqrt(math.pow(self.tee[1]-self.pin[1], 2)+math.pow(self.tee[3]-self.pin[3], 2)) * 0.312495

                -- Format
                self.distancia = string.format('%0.2f', self.distancia)

                -- Calcula Altura
                self.altura = (self.pin[2] - self.tee[2] + 0.14) * (0.312495 * 0.914)

                -- Format
                self.altura = string.format('%0.2f', self.altura)
            end
        end
    end,
    getAnguloAndPowerBarStruct = function(self)

        const_addr_mira_sin = 0x00EC97A0 -- JP 0x00F024A0

        if self.state and self.state == true then

            sin = readFloat(const_addr_mira_sin+8)
            cos = readFloat(const_addr_mira_sin)

            if sin and cos then

                -- Calcula Power Bar
                ang_cam = math.atan2(self.tee[1]-self.pin[1], self.tee[3]-self.pin[3])

                dist = math.sqrt(math.pow(self.tee[1]-self.pin[1], 2)+math.pow(self.tee[3]-self.pin[3], 2))

                if self.grid_mira_radiano &gt; 0 then

                    rad2 = readFloat(self.grid_mira_radiano)

                    rad = math.fmod(math.abs(rad2), 6.28318530717959)

                    if rad2 &lt; 0 then
                        rad = rad * -1
                    end

                    --self.pb = math.sin(rad + ang_cam) * dist * 0.9623
                    self.pb = (dist * 0.3125) * math.tan(rad + ang_cam) / 1.5 / 0.2167 * -1
                end

                -- Cacula Ângulo Mira
                graus_sin = tonumber(string.format('%.2f', math.deg(math.asin(sin))))
                graus_cos = tonumber(string.format('%.2f', math.deg(math.acos(cos))))

                if not graus_cos then
                    graus_cos = 0
                end

                if not graus_sin then
                    graus_sin = 0
                end

                if graus_sin &lt; 0.0 then
                    self.mira = 180.0 - (graus_cos - 180.0)
                else
                    self.mira = graus_cos
                end

                -- Disconta o ângulo do vento com o da mira
                self.mira = math.fmod(360 - ((self.mira - self.wind[2]) - 360), 360)
            end
        end

    end,
    getCurrentPlayer = function(self, addr_mngr, index)

        ret_curr_player = nil

        if addr_mngr ~= nil and addr_mngr ~= 0 then

            ptr = readInteger(addr_mngr + 0xC8)

            if ptr ~= nil and ptr ~= 0 then

                index_arr = readBytes('[' .. string.format("%x", self.const_addr_power_gauge) .. ']+F9B4', 1, false) -- JP +10594

                index_arr = index_arr - 4

                if (index_arr &gt;= 0 or index_arr &lt; 7) and (index_arr ~= 3 and index_arr ~= 4) then
                    ret_curr_player = ptr
                else

                    if (index &amp; 0xFF) &lt; readBytes(addr_mngr + 0xD5, 1, false) then

                        ret_curr_player = ptr + (index * 0xDA0) -- JP 0xDB0
                    end
                end
            end
        end

        return ret_curr_player
    end,
    getObjectPowerGaugePlayer = function(self, addr_mngr, index)

        ret_obj_power_gauge = nil

        if addr_mngr ~= nil and addr_mngr ~= 0 then

            ptr = readInteger(addr_mngr + 0xCC)

            if ptr ~= nil and ptr ~= 0 then
                ret_obj_power_gauge = ptr + (index * 0x3B4)
            end
        end

        return ret_obj_power_gauge
    end,
    getPowerGaugeObjectCurrentPlayer = function(self)

        -- 0x39C or 0x4C8 - Value
        -- 0x3A0 or 0x4CC - Mask
        -- 0x3A4 or 0x4D0 - Hash

        ret_obj_power_gauge = nil

        mngr = readInteger('[' .. string.format("%x", self.const_addr_power_gauge) .. ']+103F4') -- JP +11024

        if mngr ~= nil and mngr ~= 0 then

            if readBytes('[' .. string.format("%x", self.const_addr_power_gauge) .. ']+F9B4', 1, false) == 1 then -- JP +10594

                player_index = readBytes(mngr + 0x185, 1, false) -- JP 0x189

                player = self:getCurrentPlayer(mngr, player_index)

                if player ~= nil and player ~= 0 then

                    power_gauge_index = readBytes(player + 0x4DD, 1, false) -- JP 0x4E9

                    power_gauge_obj = self:getObjectPowerGaugePlayer(mngr, power_gauge_index)

                    if power_gauge_obj ~= nil and power_gauge_obj ~= 0 then
                        ret_obj_power_gauge = power_gauge_obj + 0x39C
                    end
                end
            else

                player_index = readBytes(mngr + 0x185, 1, false) -- JP 0x189

                player = self:getCurrentPlayer(mngr, player_index)

                if player ~= nil and player ~= 0 then
                    ret_obj_power_gauge = player + 0x4BC -- JP 0x4C8
                end
            end
        end

        return ret_obj_power_gauge
    end,
    getPowerGaugeStruct = function(self)

        -- Get Power Gauge
        power_gauge_obj = self:getPowerGaugeObjectCurrentPlayer()

        if power_gauge_obj ~= nil and power_gauge_obj ~= 0 then

            -- 0x00 value
            -- 0x04 mask
            -- 0x08 hash

            hash_power_gauge = readInteger(power_gauge_obj + 0x08) -- 0x08 Hash

            hash_power_gauge = ~(hash_power_gauge ~ readInteger(power_gauge_obj + 0x00)) &amp; 0xFFFFFFFF -- 0x00 Value

            self.power_gauge = byteTableToFloat(dwordToByteTable(hash_power_gauge))
        end
    end,
    changeWind = function(self, wind_speed, wind_direction, option)

        wind = self:getClassicWindStruct()

        if wind then

            wind:init(option)

            if wind.table_wind_value then

              if wind_speed and tonumber(wind_speed) then
                -- Update Wind Speed
                wind.table_wind_value.wind_speed = wind_speed
              end

              if wind_direction and tonumber(wind_direction) then
                -- Updat Wind Direction
                wind.table_wind_value.wind_direction = wind_direction
              end

              wind.table_wind_value:makeWindAndAng(wind.this)
            end
        else
            if option == 0 then
                print('Não conseguiu encontrar o Wind.')
            end
        end
    end,
    changePowerGauge = function(self, new_value)

        -- Set Power Gauge
        if new_value == nil then
            new_value = 99.0
        end

        if new_value ~= self.power_gauge then

            self.power_gauge = new_value;

            power_gauge_obj = self:getPowerGaugeObjectCurrentPlayer()

            if power_gauge_obj ~= nil and power_gauge_obj ~= 0 then

                -- 0x00 value
                -- 0x04 mask
                -- 0x08 hash

                hash_value = byteTableToDword(floatToByteTable(self.power_gauge))

                hash_value = (~hash_value &amp; 0xFFFFFFFF) ~ readInteger(power_gauge_obj + 0x08)

                mask = (power_gauge_obj + 0x00) ~ hash_value

                writeInteger(power_gauge_obj + 0x00, hash_value)
                writeInteger(power_gauge_obj + 0x04, mask)
            end
        end

    end,
    getSlopeBreak = function(self)

         const_addr_mira_sin = 0x00EC97A0 -- JP 0x00F024A0

         sin = readFloat(const_addr_mira_sin+8)
         cos = readFloat(const_addr_mira_sin)

         -- Cacula Ângulo Mira
         graus_sin = tonumber(string.format('%.2f', math.deg(math.asin(sin))))
         graus_cos = tonumber(string.format('%.2f', math.deg(math.acos(cos))))

         if not graus_cos then
             graus_cos = 0
         end

         if not graus_sin then
             graus_sin = 0
         end

         mira = 0

         if graus_sin &lt; 0.0 then
             mira = 180.0 - (graus_cos - 180.0)
         else
             mira = graus_cos
         end

         -- Slope Break
         if self.grid_mira_radiano ~= nil and self.grid_mira_radiano ~= 0
            and self.ball_ground[1] ~= nil and self.ball_ground[1] ~= 0
            and self.ball_ground[2] ~= nil and self.ball_ground[2] ~= 0
            and sin ~= nil and sin ~= 0 and cos ~= nil and cos ~= 0
            and readFloat(self.grid_mira_radiano) ~= nil and readFloat(self.ball_ground[1]) ~= nil and readFloat(self.ball_ground[2]) ~= nil then

            -- atan2 = ang_cam
            mira_radiano = mira * 3.1415926535897932384626433832795 / 180

            --mira_radiano = math.fmod(mira_radiano, 3.1415926535897932384626433832795)

            mira_radiano = mira_radiano * -1

            cos = math.cos(mira_radiano)
            sin_neg = math.sin(mira_radiano) * -1

            --if math.deg(mira_radiano) ==

            -- ball_ground[] = [1] = X, [2] = Z
            return ((readFloat(self.ball_ground[1]) * cos) + (readFloat(self.ball_ground[2]) * sin_neg)) * -1 * (1 / 0.00875) --128
         end

         return 0.0
    end,
    makeAllRecord = function(self, option)
        sg = self:getSlopGroundStruct()
        s = self:getSpinStruct()
        wind = self:getClassicWindStruct()
        grid = self:getGridStruct()

        if sg then
           sg:init(option)

           -- Initialize data
           self.ground = sg.ground
           self.ball_ground[1] = sg.ground_x
           self.ball_ground[2] = sg.ground_y
           self.ball_line = sg.line_rotate
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Slop Ground')
            end
        end

        if s then
           s:init(option)

           -- Initialize data
           self.ball_effect[1] = s.spin
           self.ball_effect[2] = s.curva
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Spin')
            end
        end

        if wind then
            wind:init(option)

            -- Initialize data
            self.wind[1] = wind.wind_speed
            self.wind[2] = wind.wind_direction
            self.wind_rotate = wind.wind_rotate
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Wind')
            end
        end

        -- Tee and Pin
        self:getTeeAndPinStruct()

        -- Grid esse tem o radianos da mira do player,
        -- esse tem que ser primeiro que o angulo e power bar por que ele usa no power bar
        if grid then

            grid:init()

            -- Initialize data
            self.grid_mira_radiano = grid.grid_mira_radiano
        else
            if option == 0 then
                showMessage('Não conseguiu encontrar o Grid')
            end
        end

        -- Ângulo Mira e Power Bar
        self:getAnguloAndPowerBarStruct()

        -- Get Power Gauge
        self:getPowerGaugeStruct()
    end
}

local search = MapSearch

-- Initialize
search:init()

-- Freeze values
local ball_line_rotate = {
    freeze = false,
    value = 0
}
local wind_rotate = {
    freeze = false,
    value = 0
}
local freeze_spin = {
    freeze = false,
    value = 0
}
local freeze_curva = {
    freeze = false,
    value = 0
}
local freeze_wind = {
    freeze = false,
    value = 0
}
local freeze_degree = {
    freeze = false,
    value = 0
}
local freeze_slope_x = {
    freeze = false,
    value = 0
}
local freeze_slope_y = {
    freeze = false,
    value = 0
}
local freeze_power_gauge_full = {
    freeze = false,
    value = 99.0
}
--
local edits = {
    spin = false,
    curva = false,
    vento = false,
    angulo = false,
    terreno = false,
    slope_x = false,
    slope_y = false
}
--

-- Hot Key Wind Rotate increse value
function increaseWindRotateValue(sender)

    if EditView.cbWindRotate.State and wind_rotate.freeze then

        -- Increase value by 0.25
        wind_rotate.value = wind_rotate.value + 0.25
    end
end

local wind_rotate_hk = createHotkey(increaseWindRotateValue, VK_CONTROL, VK_ADD)
--

RequiredCEVersion=6.5
if (getCEVersion==nil) or (getCEVersion()&lt;RequiredCEVersion) then
  messageDialog('Please install Cheat Engine '..RequiredCEVersion, mtError, mbOK)
  closeCE()
end
addresslist=getAddressList()

getAutoAttachList().add("ProjectG.exe")
EditView.show()

function Timer(sender)

    -- Update
    search:makeAllRecord()

    -- Rotação do vento
    if wind_rotate.freeze == false then

        -- Upadate
        wind_rotate.value = readFloat(search.wind_rotate)

    end

    -- Ball line roate
    if ball_line_rotate.freeze == false then

        -- Update
        ball_line_rotate.value = readFloat(search.ball_line)

    end

    -- Power gauge Full -- quando fazer o edit power gauge
    --if freeze_power_gauge_full.freeze == false then
    --end

    -- Spin e Curva

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.spin then

      spin = readFloat(search.ball_effect[1])

      if spin then
          EditView.eSpin.Text = string.format('%.2f', spin)
      else
          EditView.eSpin.Text = 0.00
      end

    end

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.curva then

      curva = readFloat(search.ball_effect[2])

      if curva then
          EditView.eCurva.Text = string.format('%.2f', curva)
      else
          EditView.eCurva.Text = 0.00
      end
    end

    -- Bola Slope

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.slope_x then

      slope_x = readFloat(search.ball_ground[1])

      if slope_x then
          EditView.eSlopeX.Text = string.format('%.9f', slope_x)
      else
          EditView.eSlopeX.Text = 0.00
      end
    end

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.slope_y then

      slope_y = readFloat(search.ball_ground[2])

      if slope_y then
          EditView.eSlopeY.Text = string.format('%.9f', slope_y)
      else
          EditView.eSlopeY.Text = 0.00
      end
    end

    -- Vento e Ângulo

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.vento then
        EditView.eWind.Text = search.wind[1]
    end

    if not edits.angulo then
        EditView.eDegree.Text = search.wind[2]
    end

    -- Terreno

    -- Só atualiza o edit box se o player não estiver digitando nele
    if not edits.terreno then
        -- Signed
        terreno = readInteger(search.ground)

        if terreno then
          if (terreno &amp; 0x80000000) &gt; 0 then
              terreno = ((~terreno &amp; 0xFFFFFFFF) + 1) * -1
          end

          EditView.lGround.Caption = string.format('%.0f%%', 100 - terreno)
        end
    end

    -- Distância
    EditView.lDistance.Caption = search.distancia .. 'y'

    -- Altura
    EditView.lAltura.Caption = search.altura .. 'm'

    -- Power Bar
    EditView.lPB.Caption = string.format('%0.2f', search.pb)

    -- Ângulo Mira
    EditView.lDegreeAim.Caption = string.format('%0.2f', search.mira)

    -- Slope Break
    EditView.lSlope.Caption = string.format('%0.2f', search:getSlopeBreak())
end

function cbWindRotateChange(sender)

    if sender.State == cbChecked then

        -- Freeze Wind Rotate
        wind_rotate.freeze = true

        -- Set Timer
        EditView.tWindRotate.setOnTimer(tWindRotateTimer)
        EditView.tWindRotate.setEnabled(true)
    else
        -- Unfreeze Wind Rotate
        wind_rotate.freeze = false

        -- Unset Timer
        EditView.tWindRotate.setOnTimer(nil)
        EditView.tWindRotate.setEnabled(false)
    end
end

function cbBallLineChange(sender)

    if sender.State == cbChecked then

        -- Freeze Ball Line Rotate
        ball_line_rotate.freeze = true

        -- Set Timer
        EditView.tBallLineRotate.setOnTimer(tBallLineRotateTimer)
        EditView.tBallLineRotate.setEnabled(true)
    else
        -- Unfreeze Ball Line Rotate
        ball_line_rotate.freeze = false

        -- Unset Timer
        EditView.tBallLineRotate.setOnTimer(nil)
        EditView.tBallLineRotate.setEnabled(false)
    end
end

function cbPowerGaugeChange(sender)

    if sender.State == cbChecked then

        -- Freeze Power Gauge
        freeze_power_gauge_full.freeze = true

        freeze_power_gauge_full.value = 99.0 -- Full

        -- Set Timer
        EditView.tPowerGauge.setOnTimer(tPowerGaugeTimer)
        EditView.tPowerGauge.setEnabled(true)
    else
        -- Unfreeze Power Gauge
        freeze_power_gauge_full.freeze = false

        -- Unset Timer
        EditView.tPowerGauge.setOnTimer(nil)
        EditView.tPowerGauge.setEnabled(false)
    end
end

function btnPowerGaugeFullClick(sender)

     -- Change Power Gauge to 3 gauge full
     search:changePowerGauge(99.0)
end

function tWindRotateTimer(sender)

     -- Update (Freeze) mesmo value
     if search.wind_rotate ~= nil and search.wind_rotate ~= 0 then
        writeFloat(search.wind_rotate, wind_rotate.value)
     end
end

function tBallLineRotateTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_line ~= nil and search.ball_line ~= 0 then
        writeFloat(search.ball_line, ball_line_rotate.value)
    end
end

function tPowerGaugeTimer(sender)

    -- Update (Freeze) mesmo value
    search:changePowerGauge(freeze_power_gauge_full.value)
end

-- Spin Freeze Methods
function cbSpinChange(sender)

    if sender.State == cbChecked then

        -- Freeze Spin
        freeze_spin.freeze = true

        -- Set Current Value
        if search.ball_effect[1] ~= nil and search.ball_effect[1] ~= 0 then
            freeze_spin.value = readFloat(search.ball_effect[1])
        end

        -- Set Timer
        EditView.tSpinFreeze.setOnTimer(tSpinFreezeTimer)
        EditView.tSpinFreeze.setEnabled(true)
    else
        -- Unfreeze Spin
        freeze_spin.freeze = false

        -- Unset Timer
        EditView.tSpinFreeze.setOnTimer(nil)
        EditView.tSpinFreeze.setEnabled(false)
    end
end

function tSpinFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_effect[1] ~= nil and search.ball_effect[1] ~= 0 then
        writeFloat(search.ball_effect[1], freeze_spin.value)
    end
end
-- End Spin Freeze Methods

-- Curva Freeze Methods
function cbCurvaChange(sender)

    if sender.State == cbChecked then

        -- Freeze Curva
        freeze_curva.freeze = true

        -- Set Current Value
        if search.ball_effect[2] ~= nil and search.ball_effect[2] ~= 0 then
            freeze_curva.value = readFloat(search.ball_effect[2])
        end

        -- Set Timer
        EditView.tCurvaFreeze.setOnTimer(tCurvaFreezeTimer)
        EditView.tCurvaFreeze.setEnabled(true)
    else
        -- Unfreeze Curva
        freeze_curva.freeze = false

        -- Unset Timer
        EditView.tCurvaFreeze.setOnTimer(nil)
        EditView.tCurvaFreeze.setEnabled(false)
    end
end

function tCurvaFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_effect[2] ~= nil and search.ball_effect[2] ~= 0 then
        writeFloat(search.ball_effect[2], freeze_curva.value)
    end
end
-- End Curva Freeze Methods

-- Slope X Freeze Methods
function cbSlopeXChange(sender)

    if sender.State == cbChecked then

        -- Freeze Slope X
        freeze_slope_x.freeze = true

        -- Set Current Value
        if search.ball_ground[1] ~= nil and search.ball_ground[1] ~= 0 then
            freeze_slope_x.value = readFloat(search.ball_ground[1])
        end

        -- Set Timer
        EditView.tSlopeXFreeze.setOnTimer(tSlopeXFreezeTimer)
        EditView.tSlopeXFreeze.setEnabled(true)
    else
        -- Unfreeze Slop X
        freeze_slope_x.freeze = false

        -- Unset Timer
        EditView.tSlopeXFreeze.setOnTimer(nil)
        EditView.tSlopeXFreeze.setEnabled(false)
    end
end

function tSlopeXFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_ground[1] ~= nil and search.ball_ground[1] ~= 0 then
        writeFloat(search.ball_ground[1], freeze_slope_x.value)
    end
end
-- End Slope X Freeze Methods

-- Slope Y Freeze Methods
function cbSlopeYChange(sender)

    if sender.State == cbChecked then

        -- Freeze Slope Y
        freeze_slope_y.freeze = true

        -- Set Current Value
        if search.ball_ground[2] ~= nil and search.ball_ground[2] ~= 0 then
            freeze_slope_y.value = readFloat(search.ball_ground[2])
        end

        -- Set Timer
        EditView.tSlopeYFreeze.setOnTimer(tSlopeYFreezeTimer)
        EditView.tSlopeYFreeze.setEnabled(true)
    else
        -- Unfreeze Slope Y
        freeze_slope_y.freeze = false

        -- Unset Timer
        EditView.tSlopeYFreeze.setOnTimer(nil)
        EditView.tSlopeYFreeze.setEnabled(false)
    end
end

function tSlopeYFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    if search.ball_ground[2] ~= nil and search.ball_ground[2] ~= 0 then
        writeFloat(search.ball_ground[2], freeze_slope_y.value)
    end
end
-- End Slope Y Freeze Methods

-- Wind Freeze Methods
function cbWindChange(sender)

    if sender.State == cbChecked then

        -- Freeze Wind
        freeze_wind.freeze = true

        -- Set Current Value
        freeze_wind.value = search.wind[1]

        -- Set Timer
        EditView.tWindFreeze.setOnTimer(tWindFreezeTimer)
        EditView.tWindFreeze.setEnabled(true)
    else
        -- Unfreeze Wind
        freeze_wind.freeze = false

        -- Unset Timer
        EditView.tWindFreeze.setOnTimer(nil)
        EditView.tWindFreeze.setEnabled(false)
    end
end

function tWindFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    search:changeWind(freeze_wind.value, nil, 1)
end
-- End Wind Freeze Methods

-- Degree Freeze Methods
function cbDegreeChange(sender)

    if sender.State == cbChecked then

        -- Freeze Degree
        freeze_degree.freeze = true

        -- Set Current Value
        freeze_degree.value = search.wind[2]

        -- Set Timer
        EditView.tDegreeFreeze.setOnTimer(tDegreeFreezeTimer)
        EditView.tDegreeFreeze.setEnabled(true)
    else
        -- Unfreeze Degree
        freeze_degree.freeze = false

        -- Unset Timer
        EditView.tDegreeFreeze.setOnTimer(nil)
        EditView.tDegreeFreeze.setEnabled(false)
    end
end

function tDegreeFreezeTimer(sender)

    -- Update (Freeze) mesmo value
    search:changeWind(nil, freeze_degree.value, 1)
end
-- End Degree Freeze Methods

function eSpinKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_effect[1] ~= nil and search.ball_effect[1] ~= 0 then

            -- Set Freeze Value
            if freeze_spin.freeze then
                freeze_spin.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_effect[1], tonumber(sender.Text))
        end

        -- Update state
        edits.spin = false
    else
        -- Update state
        edits.spin = true
    end

    return key
end

function eCurvaKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_effect[2] ~= nil and search.ball_effect[2] ~= 0 then

            -- Set Freeze Value
            if freeze_curva.freeze then
                freeze_curva.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_effect[2], tonumber(sender.Text))
        end

        -- Update state
        edits.curva = false
    else
        -- Update state
        edits.curva = true
    end

    return key
end

function eDegreeKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) then

            -- Set Freeze Value
            if freeze_degree.freeze then
                freeze_degree.value = tonumber(sender.Text)
            end

            search:changeWind(nil, sender.Text, 1)
        end

        -- Update state
        edits.angulo = false
    else
        -- Update state
        edits.angulo = true
    end

    return key
end

function eWindKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) then

            -- Set Freeze Value
            if freeze_wind.freeze then
                freeze_wind.value = tonumber(sender.Text)
            end

            search:changeWind(sender.Text, nil, 1)
        end

        -- Update state
        edits.vento = false
    else
        -- Update state
        edits.vento = true
    end

    return key
end

function eSlopeXKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_ground[1] ~= nil and search.ball_ground[1] ~= 0 then

            -- Set Freeze Value
            if freeze_slope_x.freeze then
                freeze_slope_x.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_ground[1], tonumber(sender.Text))
        end

        -- Update state
        edits.slope_x = false
    else
        -- Update state
        edits.slope_x = true
    end

    return key
end

function eSlopeYKeyPress(sender, key)

    if key == '\x0d' then

        -- Update value
        if sender.Text and tonumber(sender.Text) and search.ball_ground[2] ~= nil and search.ball_ground[2] ~= 0 then

            -- Set Freeze Value
            if freeze_slope_y.freeze then
                freeze_slope_y.value = tonumber(sender.Text)
            end

            writeFloat(search.ball_ground[2], tonumber(sender.Text))
        end

        -- Update state
        edits.slope_y = false
    else
        -- Update state
        edits.slope_y = true
    end

    return key
end

function FormClose(sender)

    -- Destroy Hotkey
    if wind_rotate_hk then
        wind_rotate_hk.destroy()
        wind_rotate_hk = nil
    end

    closeCE()
    return caFree --Possible options: caHide, caFree, caMinimize, caNone
end
</LuaScript>
</CheatTable>